* Chapter 11 File-System Implementation
** File-System Structure
  - basic file system :: issues generic commands to appropriate device drivers
       | Layered Ô¨Åle system       |
       | ------------------------ |
       | application programs     |
       | file-organization module |
       | logical file system      |
       | basic file system        |
       | I/O control              |
       | devices                  |
       v v
       
  - file-organization module :: knows about files and their logical blocks
       as well as physical blocks. This module can translate logical
       block addresses to phyical blocked addresses. Also provides
       free-space manager
       
  - logical file system :: manages metadata
    - all file system structure except the actual data (i.e contents of files)
    - provies directory structure to provide file organization module
    - maintains file structure via file-control block (inode in UNIX)
    - responsible for protection and security
      
  - file-control block (FCB) :: contains information about the file, including
       ownership, permissions, and location of file contents.
       | Typical FCB                                      |
       | ------------------------------------------------ |
       | file permissions                                 |
       | file dates (create, access, write)               |
       | file owner, group, ACL                           |
       | file size                                        |
       | file data blocks or pointers to file data blocks |
       
** File-System Implmentation
   Information in file systems
   - boot control block :: info needed by system to boot an OS from that volume
        
   - volume control block :: contains partition details such as number of blocks
        in partition, size of blocks, free block-count, free-block
        pointers, free-FCB count, and FCB pointers.  In UFS called a
        superblock.  In NTFS caled the master file table
        
        
   The in-memory information is loaded at mount time, updated during
   file-system operations, and discared at dismount. Several types of
   structires are involved:
   - mount table :: in memory infomation about each monuted volume
                    
   - system-wide open-file table :: contains a copy of FCB of each open file and
        other information
        
   - per-process open-file table :: contains pointers to appropriate entry in
        the system-wide open-file table
        
   - buffers to hold file-system blocks when being read from disk or written
     to disk
     
   File Creation - application program calls the logical file system
   where the LFS allocates a new FCB, reads the appropriate directory
   into memory, updates it with new file name and FCB, and writes it
   back to disk.
   
   Note: UNIX treats a directory exactly the same as a file (includes
   a "type" field indicating it is a directory
   
   Once file is created, it can be used for I/O. open() call passed a
   file name to the logical file system. First, search done on
   system-wide open-file table to see if the file is already in use by
   another process. If not, directory structure is searched for the
   given file name. Once file is found, the FCB is copied into the
   system-wide open-file table in memory. This table not only stores
   the FCB but also tracks the number of processes that have file
   open.
   
   - file descriptor (UNIX), file handle (Windows) :: name given to the entry
        in the open-file table
        
   When file is closed, per-process table entry is removed, and
   system-wide entry's open count is decremented. When all users that
   have opened the file close, any updated metadata is copied back to
   the disk-based directory structure, and system- wide open file
   table entry is removed.
   
** Virtual File Systems
   Why? To allow and operating system to allow multiple types of file
   systems to be integrated into a directory structure
   
** Directory Implementation
   Directory-allocation and directory-management algorithms
   
   Linear List
   - Linear list of file names with pointers to the data blocks 
     
   Hash Table
   - Hash table takes a value computed from the file name and return a pointer
     to the file name in the linear list therefore greatly decreasing
     the directory search time.
     
** Allocation Methods
   Direct-access nature of disks allows flexibility in the
   implementation of files.  Main isue is how to allocate space to
   these files so that disk space is utilized effectively and files
   can be accessed quickly. Three magor methods of allocating disk
   space:
   
*** Contiguous Allocation
    Requires each file occupy a set of contiguous blocks on the
    disk. Disk addresses define a linear ordering on the disk.
    
    Has problems in finding space for a new file. Either first-fit or
    best-fit algorithms are used but can results in external
    fragmentation.
    
    To make efficient use of disk space, modified
    contiguous-allocation schemes exists. If an amount allocated to a
    file proves to not be large enough, another chunk of contiguous
    space, known as *extent* is allocated.
    
*** Linked Allocation
    Solves all problems of contiguous allocation:
    - Each file is a linked list of disk blocks meaning the disk blocks can be
      scattered anywhere on disk
    - Directory contrains pointer to first and last block of the file
    - Each block contains a pointer to the next block
      - block is 512 bytes in size, 4 bytes of which are pointers to the 
        next block thus user sees blocks of 508 bytes
        
    _File creation_ Create a new entry in the directory where each
    directory entry has a pointer to the first disk block of the
    file. This pointer is initialized to nil to signifiy an empty
    file. Size field also set to 0. A write will cause the free-space
    management system to find a free block and this new block is
    written to and is linked to the end of the file
    
    _Disadvantage_
    - Can be used effectively only for sequential-access files. Inefficient
      direct access support if underlying structure is linkedin list
    - 4 bytes out of 512 are for pointers which means 0.78 percent of
      disk is being used for pointers (Solution: disadvantage of
      wasted pointer space is to collect blocks into multiples called
      *clusters* and allocated clusters at a time.)
    - Too much reliability on pointers being valid. If a bug were to corrupt
      pointer, wrong data blocks would be retrieved

    - file-allocation table :: An important variation on linked allocation
      + Section of disk at beginning of each volume is set aside to contain 
        the table
      + Table has one entry for each disk block and is indexed by block number
      + Directory entry contains the block number of the first block of the file
      + Table entry indexed by block number contains block number of next block 
        in the file.
      + This chain is continued until the last block is reached which has special
        end-of-file value as table entry
      + Unused block has table value of 0. Block allocation is simple
        matter of finding first 0-valued table entry and replacing
        previous end-of-file value with address of new block. The 0 is
        then replaced with end-of-file value
      + benefit of this approach is that the FAT table can be cached
        in memory, greatly improving random access speeds.

        
*** Indexed Allocation
    Indexed allocation solves external-fragmentation and
    size-declaration problem of contiguous allocation. All pointers of
    a file are brough together in what is known as the *index block*
    (array of disk-block addresses)

   - Each file has own index block
   - Directory contains the address of the index block
   - When file is created, all pointers in index block are set to nil
   - When ith block is first written, a block is obtained from the
     free-space manager, and its address is put in the ith index-block
     entry

   Pros: Supports direct access without suffering from external
   fragmentation Cons: Suffers from wasted space. Pointer overhead is
   generally greater than pointer overhead of linked allocation

   _How large should index block be?_
   - Linked scheme :: link index blocks
   - Multilevel index :: Variant of linked scheme where first-leve
        index block to point to a set of second-level index blocks,
        which in turn point to the file blocks. I.e with 4096-byte
        blocks, we could store 1024 four-byte pointers in an index
        block. Two levels of indexes allow 1048576 (1024^2) data
        blocks and a file size up to 4 GB.
        
        
   Indexed-allocation scheme suffer form some of the same performance problems
   as does linked allocation. The index block can be cached in memory,
   but the data blocks may be spread all over a volume

** Performance concerns
    For any type of access (random or sequential), contiguous allocation
    requires only once access to get a disk block. We can easily keep the initial
    memory address of the file in memory and can calculate the other blocks via
    offset of the initial

    For linked allocation, address of the next block can be kept in memory 
    and read directly. Although this works fine for sequential access, for direct
    access, an access to the ith block may require i disk reads.

** Free-Space Management
   - free-space list :: To keep track of free disk space. Records all
        free disk blocks. Despite its name, may not be implemented as a list

   - bit vector :: free-space list implemented as bit map or bit vector. 
                   Each bloack is represented by 1 bit. If block is free,
                   the bit is 1, if block is allocated, bit is 0.
                   Cons - inefficient unless entire vector is kept
                   in memory, but then it takes up more memory as size of
                   disk increases

   - linked list :: link together all free disk blocks. FAT method incorporates
                    free-block accounting into the allocation data structure

** Efficieny and Performance
   - UNIX inodes are preallocated on a volume for efficiency even though 
     this means an "empty" disk has a percentage of its space list to inodes.
     However, by preallocation inodes and spreading them across the volume,
     improve fs performance.
     Neat - UNIX tries to keep a file's data block near that file's inode block
     to reduce disk seek time.

* Chapter 7 Deadlocks
** Deadlock characterization
   Deadlock can only arise iff conditions hold simultaneously
   - Mutual Exclusion :: At least one resource held in a nonsharable mode
   - Hold and wait :: Process must hold at least one resource and wait to acquire
                      additional resource held by other processes
   - No preemption :: resource can only be released voluntarily by process holding it
   - Circular wait :: A set {P0,P1,...,Pn} waiting processes must exist such that
                      P0 waits on P1, P1 waits on P2, ... , Pn waits on P0.

   With resource allocation graphs, if graphs contains no cycles, then no process in
   the system is deadlocked. Deadlock can exists iff there is a cycle (but not necessarily
   occured)

** Methods for handling deadlocks
   - Deadlock prevention :: provides methods to ensure at least one of the necessary
        conditions does not hold
   - Deadlock avoidance :: OS given in advance additional information concerning which
        resource a process will request and use
   - Deadlock ignorance :: Since deadlocks occur infrequently, allow then to take up
        resources until system reboot

*** Deadlock prevention
**** Mutual Exclusion
     Have only sharable resources
**** Hold and wait
     Must have it whenever process requests a resource, it doesn't hold any other resources.
    - One protocol is to require each process to request and be allocated all its resources
      before it begins execution
    - Another is to allow request for resources only when process has none
      
    Both protocols have disadvantages however since allocated resources may be unused for
    a long time. Also, starvation of processes is possible since one of the many requested
    resources may be always used by some other process.
**** No preemption
     No premption of resources that have already been allocated. 
     Protocol: 
     If process is holding some resources and requests another resource that cannot be
     immediately allocated (i.e will have to wait), then all currently held resources are
     preempted. The pro cess will restart only when it can regain its old resources as well
     as receiving the new ones it is requesting.
     
**** Circular wait
     One way to ensure this condition never holds is to impose a total ordering of all
     resource types and require each process request resources in an increasing order
     of enumeration.
     
     _Proof by contradition circular wait cannot hold_
     Let the set of processes involved in the circular wait be {P0, P1, ..., Pn} where Pi
     is waiting for a resource Ri which is held by process Pi+1 (let Rn be held by P0). 
     Since process Pi+1 is holding resource Ri while requesting Ri+1, we must have 
     F(Ri) < F(Ri+1) for all i. But this would be mean F(Rn) < F(R0) which is impossible.

*** Deadlock avoidance
    Deadlock avoidance algorithm dynamically examines the resource-allocation state
    to ensure a circulate wait condition never exists. /state/ is de fined by number of 
    available and allocated resources and maximum demands of the processes.

    - Safe State :: system can allocate resources to each process in some order and 
                    still avoid a deadlock. Formally, a system is in safe state iff there
                    exists a /safe sequence/. 
    - Safe sequence :: A sequence of processes <P1 , P2 , ..., Pn > 
                       is a safe sequence for the current allocation state if, 
                       for each Pi , the resource requests that Pi can make 
                       can be satisÔ¨Åed by the currently available resources 
                       plus the resources held by all Pj , with j < i.

    With this scheme, if a requested resource is available, it may still have to 
    wait thus overall resource utilization may be lower than it would be.

**** Resource Allocation Graph Algorithms
    - Before request is granted to process, claim edges are checked to make sure
      no cycle will occur once claim edges are converted to assignment edges. 
      O(n^2)

    - Bankers Algorithm :: Above algorithm not applicable to resource allocation
         system with multiple instances of each resource type. Four data structures
         required:
      - Available :: # avail resource of each  type
      - Max :: 2D matrix defined maximum demand of each process
      - Allocation :: 2D matrix defined number of resources of each type 
                      currently allocated
      - Need :: 2D matrix indicates remaining resource need of each process

         Each process must apriori claim its maximum use of processes. O(mn^2)

*** Deadlock Detection
    When should we invoke detection algorithm
    Must answer:
    1) How often is a deadlock likely to occur?
    2) How many processes will be affected by deadlock when it happens?

    Deadlock detection algorithms run in O(mn^2)

*** Recover from Deadlock
    Two options for breaking a deadlock
    1) Abort all deadlocked processes - can be expensive and costly
    2) Abort one process at a time until deadlock cycle eliminated - overhead

**** Resource premption
     We successuly prempt some resources from processes and give these resources
     to other processes until the deadlock cycle is broken. For premption is
     required for dealing with deadlocks, 3 issues must be addressed:
     1) Selecting a victim
     2) Rollback - how should we restart the prempted process in the future?
     3) Starvation - How do we guarantee resource will not always be preempted
        from the same process?
       
         
                

      


     
     
     
* Chapter 8
